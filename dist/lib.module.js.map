{"version":3,"file":"lib.module.js","sources":["../src/utils/index.ts","../src/DBSClient.ts"],"sourcesContent":["import { Signer, sha256, toUtf8Bytes } from 'ethers'\n\nexport const minErc20Abi = [\n  'function approve(address, uint256) external returns (bool)',\n  'function balanceOf(address owner) external view returns (uint256)'\n]\n\n/**\n * @param {string} quoteId - The quote ID.\n * @param {Signer} signer The signer object.\n * @param {number} nonce - A timestamp (must be higher than the previously stored nonce for the user).\n * @returns {Promise<string>} - A promise that resolves to the signed hash.\n */\nexport const getSignedHash = async (signer: Signer, quoteId: string, nonce: number) => {\n  // Concatenate the message\n  const message = sha256(toUtf8Bytes(quoteId + nonce.toString()))\n\n  // Sign the original message directly\n  const signature = await signer.signMessage(message)\n\n  return signature\n}\n","import { Signer, MaxInt256, Contract } from 'ethers'\nimport axios, { AxiosResponse } from 'axios'\nimport {\n  StorageInfo,\n  GetQuoteArgs,\n  GetQuoteResult,\n  GetStatusResult,\n  GetLinkResult,\n  RegisterArgs,\n  DBSGetQuoteArgs,\n  FileData\n} from './@types'\nimport { getSignedHash, minErc20Abi } from './utils'\nimport validator from 'validator'\nimport fs from 'fs'\nimport FormData from 'form-data'\n\n/**\n * DBSClient is a TypeScript library for interacting with the DBS API.\n */\nexport class DBSClient {\n  private baseURL: string\n  private signer: Signer\n\n  /**\n   * Creates an instance of the DBSClient.\n   * @param {string} baseURL - The base URL of the DBS API.\n   * @param {Signer} signer The signer object.\n   */\n  constructor(baseURL: string, signer?: Signer) {\n    this.validateBaseURL(baseURL)\n    this.baseURL = baseURL\n    this.signer = signer\n  }\n\n  private validateBaseURL(baseURL: string): void {\n    if (!baseURL || typeof baseURL !== 'string' || baseURL.trim() === '') {\n      throw new Error('Invalid baseURL provided. baseURL cannot be empty or undefined.')\n    }\n\n    // Using the validator library to check for a valid URL.\n    // Including { require_tld: false } to allow 'localhost' as a valid URL.\n    if (!validator.isURL(baseURL, { require_tld: false })) {\n      throw new Error('Invalid baseURL format provided.')\n    }\n  }\n\n  private getFileSizes(files: string[]): FileData[] {\n    return files.map((file) => {\n      const stats = fs.statSync(file)\n      return {\n        length: stats.size\n      }\n    })\n  }\n\n  /**\n   * Fetches information about supported storage types and payments.\n   *\n   * @returns {Promise<StorageInfo[]>} - A promise that resolves to an array of storage information.\n   */\n  async getStorageInfo(): Promise<StorageInfo[]> {\n    const response = await axios.get<StorageInfo[]>(`${this.baseURL}/`)\n    return response.data\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage.\n   *\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>} - A promise that resolves to the quote result.\n   */\n  async getQuote(args: GetQuoteArgs): Promise<GetQuoteResult> {\n    if (!args.filePath && !args.fileInfo) {\n      throw new Error('Either filePath or fileInfo must be provided.')\n    }\n    const fileSizes: FileData[] = args.fileInfo || this.getFileSizes(args.filePath)\n\n    const payload: DBSGetQuoteArgs = {\n      type: args.type,\n      files: fileSizes,\n      duration: args.duration,\n      payment: args.payment,\n      userAddress: args.userAddress\n    }\n\n    const response = await axios.post<GetQuoteResult>(`${this.baseURL}/getQuote`, payload)\n\n    return response.data\n  }\n\n  /**\n   * Uploads files according to the quote request.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @param {Buffer[]} files - An array of files to upload.\n   * @returns {Promise<void>}\n   */\n  async upload(quoteId: string, tokenAddress: string, filePaths: string[]): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n      const address = await this.signer.getAddress()\n\n      const token = new Contract(tokenAddress, minErc20Abi, this.signer)\n\n      await (await token.approve(address, MaxInt256)).wait()\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n\n      const formData = new FormData()\n      // Add each file to the form data\n      filePaths.forEach((path, index) => {\n        formData.append(`file${index + 1}`, fs.createReadStream(path))\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n\n      const response = await axios.post(uploadUrl, formData, {\n        headers: {\n          ...formData.getHeaders()\n        }\n      })\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  async uploadBrowser(\n    quoteId: string,\n    tokenAddress: string,\n    files: FileList\n  ): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n      const address = await this.signer.getAddress()\n\n      const token = new Contract(tokenAddress, minErc20Abi, this.signer)\n\n      await (await token.approve(address, MaxInt256)).wait()\n      const signature = await getSignedHash(this.signer, quoteId, nonce) // Make sure this works in a browser context or offload to a server\n\n      const formData = new FormData()\n      // Add each file to the form data\n      Array.from(files).forEach((file, index) => {\n        formData.append(`file${index + 1}`, file.stream, {\n          knownLength: file.size,\n          filename: file.name,\n          contentType: file.type\n        })\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n\n      const response = await axios.post(uploadUrl, formData, {\n        headers: {\n          ...formData.getHeaders()\n        }\n      })\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage and uploads files according to the quote request.\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>}\n   */\n  // async getQuoteAndUpload(args: GetQuoteArgs): Promise<any> {\n  //   const quote = await this.getQuote(args)\n  //   const uploadResponse = await this.upload(quote.quoteId, args.files)\n  //   return uploadResponse\n  // }\n\n  /**\n   * Fetches the status of a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetStatusResult>} - A promise that resolves to the status result.\n   */\n  async getStatus(quoteId: string): Promise<GetStatusResult> {\n    const response = await axios.get<GetStatusResult>(`${this.baseURL}/getStatus`, {\n      params: {\n        quoteId\n      }\n    })\n    return response.data\n  }\n\n  /**\n   * Fetches the DDO files object for a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetLinkResult[]>} - A promise that resolves to an array of link results.\n   */\n\n  async getLink(quoteId: string): Promise<GetLinkResult[]> {\n    const nonce = Math.round(Date.now() / 1000)\n    const signature = await getSignedHash(this.signer, quoteId, nonce)\n    const response = await axios.get<GetLinkResult[]>(`${this.baseURL}/getLink`, {\n      params: { quoteId, nonce, signature }\n    })\n    return response.data\n  }\n\n  /**\n   * Registers a new microservice that handles a storage type.\n   *\n   * @param {RegisterArgs} args - The arguments needed for registering a microservice.\n   * @returns {Promise<void>}\n   */\n  async registerMicroservice(args: RegisterArgs): Promise<AxiosResponse> {\n    const response = await axios.post(`${this.baseURL}/register`, args)\n    return response\n  }\n}\n"],"names":["minErc20Abi","getSignedHash","signer","quoteId","nonce","message","sha256","toUtf8Bytes","toString","Promise","resolve","signMessage","e","reject","DBSClient","baseURL","this","validateBaseURL","_proto","prototype","trim","Error","validator","isURL","require_tld","getFileSizes","files","map","file","length","fs","statSync","size","getStorageInfo","axios","get","then","response","data","getQuote","args","filePath","fileInfo","fileSizes","post","payload","type","duration","payment","userAddress","upload","tokenAddress","filePaths","_this3","_catch","Math","round","Date","now","getAddress","address","token","Contract","approve","MaxInt256","_token$approve","wait","signature","formData","FormData","forEach","path","index","append","createReadStream","headers","_extends","getHeaders","error","console","uploadBrowser","_this4","_token$approve2","Array","from","stream","knownLength","filename","name","contentType","getStatus","params","getLink","_this6","registerMicroservice"],"mappings":"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"}