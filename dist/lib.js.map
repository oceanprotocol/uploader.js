{"version":3,"file":"lib.js","sources":["../src/utils/index.ts","../src/DBSClient.ts"],"sourcesContent":["import { ethers, Signer, sha256, toUtf8Bytes } from 'ethers'\n\n/**\n * @param {string} quoteId - The quote ID.\n * @param {Signer} signer The signer object.\n * @param {number} nonce - A timestamp (must be higher than the previously stored nonce for the user).\n * @returns {Promise<string>} - A promise that resolves to the signed hash.\n */\nexport const getSignedHash = async (signer: Signer, quoteId: string, nonce: number) => {\n  // Create a hash\n  const hash = sha256(toUtf8Bytes(quoteId + nonce.toString()))\n\n  // Sign the hash\n  const signedHash = await signer.signMessage(ethers.getBytes(hash))\n\n  return signedHash\n}\n","import { Signer } from 'ethers'\nimport axios from 'axios'\nimport FormData from 'form-data'\nimport {\n  StorageInfo,\n  GetQuoteArgs,\n  GetQuoteResult,\n  GetStatusResult,\n  GetLinkResult,\n  RegisterArgs,\n  AcceptedPayment,\n  FileData\n} from './@types'\nimport { getSignedHash } from './utils'\nimport validator from 'validator'\nimport fs from 'fs'\n\n/**\n * DBSClient is a TypeScript library for interacting with the DBS API.\n */\nexport class DBSClient {\n  private baseURL: string\n  private signer: Signer\n\n  /**\n   * Creates an instance of the DBSClient.\n   * @param {string} baseURL - The base URL of the DBS API.\n   * @param {Signer} signer The signer object.\n   */\n  constructor(baseURL: string, signer?: Signer) {\n    this.validateBaseURL(baseURL)\n    this.baseURL = baseURL\n    this.signer = signer\n  }\n\n  private validateBaseURL(baseURL: string): void {\n    if (!baseURL || typeof baseURL !== 'string' || baseURL.trim() === '') {\n      throw new Error('Invalid baseURL provided. baseURL cannot be empty or undefined.')\n    }\n\n    // Using the validator library to check for a valid URL.\n    // Including { require_tld: false } to allow 'localhost' as a valid URL.\n    if (!validator.isURL(baseURL, { require_tld: false })) {\n      throw new Error('Invalid baseURL format provided.')\n    }\n  }\n\n  private getFileSizes(files: string[]): FileData[] {\n    return files.map((file) => {\n      const stats = fs.statSync(file)\n      return {\n        length: stats.size\n      }\n    })\n  }\n\n  /**\n   * Fetches information about supported storage types and payments.\n   *\n   * @returns {Promise<StorageInfo[]>} - A promise that resolves to an array of storage information.\n   */\n  async getStorageInfo(): Promise<StorageInfo[]> {\n    const response = await axios.get<StorageInfo[]>(`${this.baseURL}/`)\n    return response.data\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage.\n   *\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>} - A promise that resolves to the quote result.\n   */\n  async getQuote(\n    type: string,\n    duration: number,\n    payment: AcceptedPayment,\n    userAddress: string,\n    filePath?: string[],\n    fileInfo?: FileData[]\n  ): Promise<GetQuoteResult> {\n    if (!filePath && !fileInfo) {\n      throw new Error('Either filePath or fileInfo must be provided.')\n    }\n    const fileSizes: FileData[] = fileInfo || this.getFileSizes(filePath)\n\n    const args: GetQuoteArgs = {\n      type,\n      files: fileSizes,\n      duration,\n      payment,\n      userAddress\n    }\n\n    const response = await axios.post<GetQuoteResult>(`${this.baseURL}/getQuote`, args)\n    return response.data\n  }\n\n  /**\n   * Uploads files according to the quote request.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @param {Buffer[]} files - An array of files to upload.\n   * @returns {Promise<void>}\n   */\n  async upload(quoteId: string, files: Buffer[]): Promise<any> {\n    try {\n      const nonce = Date.now()\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n      const formData = new FormData()\n      files.forEach((buffer, index) => {\n        formData.append(`file${index}`, buffer, { filename: `file${index}.bin` })\n      })\n\n      const response = await axios.post<any>(`${this.baseURL}/upload`, formData, {\n        params: { quoteId, nonce, signature },\n        headers: { ...formData.getHeaders(), 'Content-Type': 'multipart/form-data' }\n      })\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage and uploads files according to the quote request.\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>}\n   */\n  // async getQuoteAndUpload(args: GetQuoteArgs): Promise<any> {\n  //   const quote = await this.getQuote(args)\n  //   const uploadResponse = await this.upload(quote.quoteId, args.files)\n  //   return uploadResponse\n  // }\n\n  /**\n   * Fetches the status of a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetStatusResult>} - A promise that resolves to the status result.\n   */\n  async getStatus(quoteId: string): Promise<GetStatusResult> {\n    const response = await axios.post<GetStatusResult>(`${this.baseURL}/getStatus`, {\n      quoteId\n    })\n    return response.data\n  }\n\n  /**\n   * Fetches the DDO files object for a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetLinkResult[]>} - A promise that resolves to an array of link results.\n   */\n\n  async getLink(quoteId: string): Promise<GetLinkResult[]> {\n    const nonce = Date.now()\n    const signature = await getSignedHash(this.signer, quoteId, nonce)\n    const response = await axios.post<GetLinkResult[]>(`${this.baseURL}/getLink`, null, {\n      params: { quoteId, nonce, signature }\n    })\n    return response.data\n  }\n\n  /**\n   * Registers a new microservice that handles a storage type.\n   *\n   * @param {RegisterArgs} args - The arguments needed for registering a microservice.\n   * @returns {Promise<void>}\n   */\n  async registerMicroservice(args: RegisterArgs): Promise<void> {\n    await axios.post(`${this.baseURL}/register`, args)\n  }\n}\n"],"names":["getSignedHash","signer","quoteId","nonce","hash","sha256","toUtf8Bytes","toString","Promise","resolve","signMessage","ethers","getBytes","e","reject","DBSClient","baseURL","this","validateBaseURL","_proto","prototype","trim","Error","validator","isURL","require_tld","getFileSizes","files","map","file","length","fs","statSync","size","getStorageInfo","axios","get","then","response","data","getQuote","type","duration","payment","userAddress","filePath","fileInfo","fileSizes","post","upload","_this3","Date","now","signature","formData","FormData","forEach","buffer","index","append","filename","params","headers","_extends","getHeaders","_catch","error","console","getStatus","getLink","_this5","registerMicroservice","args"],"mappings":"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"}