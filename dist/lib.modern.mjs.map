{"version":3,"file":"lib.modern.mjs","sources":["../src/utils/index.ts","../src/Client.ts"],"sourcesContent":["import { Signer, sha256, toUtf8Bytes } from 'ethers'\n\nexport const minErc20Abi = [\n  'function approve(address, uint256) external returns (bool)',\n  'function balanceOf(address owner) external view returns (uint256)'\n]\n\n/**\n * @param {string} quoteId - The quote ID.\n * @param {Signer} signer The signer object.\n * @param {number} nonce - A timestamp (must be higher than the previously stored nonce for the user).\n * @returns {Promise<string>} - A promise that resolves to the signed hash.\n */\nexport const getSignedHash = async (signer: Signer, quoteId: string, nonce: number) => {\n  // Concatenate the message\n  const message = sha256(toUtf8Bytes(quoteId + nonce.toString()))\n\n  // Sign the original message directly\n  const signature = await signer.signMessage(message)\n\n  return signature\n}\n","import { Signer, MaxInt256, Contract } from 'ethers'\nimport axios, { AxiosResponse } from 'axios'\nimport {\n  StorageInfo,\n  GetQuoteArgs,\n  GetQuoteResult,\n  GetStatusResult,\n  GetLinkResult,\n  RegisterArgs,\n  DBSGetQuoteArgs,\n  FileData\n} from './@types'\nimport { getSignedHash, minErc20Abi } from './utils'\nimport validator from 'validator'\nimport fs from 'fs'\nimport FormData from 'form-data'\n\n/**\n * Client is a TypeScript library for interacting with the DBS API.\n */\nexport class Client {\n  private baseURL: string\n  private signer: Signer\n  private dbsAddress: string\n\n  /**\n   * Creates an instance of the Client.\n   * @param {string} baseURL - The base URL of the DBS API.\n   * @param {Signer} signer The signer object.\n   */\n  constructor(baseURL: string, address: string, signer?: Signer) {\n    this.validateBaseURL(baseURL)\n    this.baseURL = baseURL\n    this.signer = signer\n    this.dbsAddress = address\n  }\n\n  private validateBaseURL(baseURL: string): void {\n    if (!baseURL || typeof baseURL !== 'string' || baseURL.trim() === '') {\n      throw new Error('Invalid baseURL provided. baseURL cannot be empty or undefined.')\n    }\n\n    // Using the validator library to check for a valid URL.\n    // Including { require_tld: false } to allow 'localhost' as a valid URL.\n    if (!validator.isURL(baseURL, { require_tld: false })) {\n      throw new Error('Invalid baseURL format provided.')\n    }\n  }\n\n  private getFileSizes(files: string[]): FileData[] {\n    return files.map((file) => {\n      const stats = fs.statSync(file)\n      return {\n        length: stats.size\n      }\n    })\n  }\n\n  /**\n   * Fetches information about supported storage types and payments.\n   *\n   * @returns {Promise<StorageInfo[]>} - A promise that resolves to an array of storage information.\n   */\n  async getStorageInfo(): Promise<StorageInfo[]> {\n    const response = await axios.get<StorageInfo[]>(`${this.baseURL}/`)\n    return response.data\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage.\n   *\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>} - A promise that resolves to the quote result.\n   */\n  async getQuote(args: GetQuoteArgs): Promise<GetQuoteResult> {\n    if (!args.filePath && !args.fileInfo) {\n      throw new Error('Either filePath or fileInfo must be provided.')\n    }\n    const fileSizes: FileData[] = args.fileInfo || this.getFileSizes(args.filePath)\n\n    const payload: DBSGetQuoteArgs = {\n      type: args.type,\n      files: fileSizes,\n      duration: args.duration,\n      payment: args.payment,\n      userAddress: args.userAddress\n    }\n\n    const response = await axios.post<GetQuoteResult>(`${this.baseURL}/getQuote`, payload)\n\n    return response.data\n  }\n\n  /**\n   * Uploads files according to the quote request.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @param {Buffer[]} files - An array of files to upload.\n   * @returns {Promise<void>}\n   */\n  async upload(\n    quoteId: string,\n    tokenAddress: string,\n    quoteFee: number,\n    filePaths: string[],\n    type: string\n  ): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n\n      const token = new Contract(tokenAddress, minErc20Abi, this.signer)\n\n      // This needs to be updated to include other addresses once we have the deposit contract deployed on other networks\n      const approveAddress =\n        type === 'filecoin'\n          ? '0x0ff9092e55d9f6CCB0DD4C490754811bc0839866'\n          : this.dbsAddress\n\n      await (await token.approve(approveAddress, quoteFee)).wait()\n\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n\n      const formData = new FormData()\n      // Add each file to the form data\n      filePaths.forEach((path, index) => {\n        formData.append(`file${index + 1}`, fs.createReadStream(path))\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n      console.log('uploadUrl', uploadUrl)\n\n      const response = await axios.post(uploadUrl, formData, {\n        headers: {\n          ...formData.getHeaders()\n        }\n      })\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  async uploadBrowser(\n    quoteId: string,\n    tokenAddress: string,\n    quoteFee: number,\n    files: FileList,\n    type: string\n  ): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n\n      const token = new Contract(tokenAddress, minErc20Abi, this.signer)\n\n      // This needs to be updated to include other addresses once we have the deposit contract deployed on other networks\n      const approveAddress =\n        type === 'filecoin'\n          ? '0x0ff9092e55d9f6CCB0DD4C490754811bc0839866'\n          : this.dbsAddress\n\n      await token.approve(approveAddress, quoteFee)\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n\n      const formData = new FormData()\n      // Add each file to the form data\n      Array.from(files).forEach((file, index) => {\n        formData.append(`file${index + 1}`, file, file.name)\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n\n      const response = await axios.post(uploadUrl, formData)\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage and uploads files according to the quote request.\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>}\n   */\n  // async getQuoteAndUpload(args: GetQuoteArgs): Promise<any> {\n  //   const quote = await this.getQuote(args)\n  //   const uploadResponse = await this.upload(quote.quoteId, args.files)\n  //   return uploadResponse\n  // }\n\n  /**\n   * Fetches the status of a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetStatusResult>} - A promise that resolves to the status result.\n   */\n  async getStatus(quoteId: string): Promise<GetStatusResult> {\n    const response = await axios.get<GetStatusResult>(`${this.baseURL}/getStatus`, {\n      params: {\n        quoteId\n      }\n    })\n    return response.data\n  }\n\n  /**\n   * Fetches the DDO files object for a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetLinkResult[]>} - A promise that resolves to an array of link results.\n   */\n\n  async getLink(quoteId: string): Promise<GetLinkResult[]> {\n    const nonce = Math.round(Date.now() / 1000)\n    const signature = await getSignedHash(this.signer, quoteId, nonce)\n    const response = await axios.get<GetLinkResult[]>(`${this.baseURL}/getLink`, {\n      params: { quoteId, nonce, signature }\n    })\n    return response.data\n  }\n\n  /**\n   * Registers a new microservice that handles a storage type.\n   *\n   * @param {RegisterArgs} args - The arguments needed for registering a microservice.\n   * @returns {Promise<void>}\n   */\n  async registerMicroservice(args: RegisterArgs): Promise<AxiosResponse> {\n    const response = await axios.post(`${this.baseURL}/register`, args)\n    return response\n  }\n\n  /**\n   * Retrieves the quote history for the given user address, nonce, and signature.\n   *\n   * @returns {Promise<any>} A promise that resolves to the quote history data.\n   */\n  async getHistory(\n    page: number = 1,\n    pageSize: number = 25,\n    storageType: string\n  ): Promise<any> {\n    try {\n      const userAddress = await this.signer.getAddress()\n      const nonce = Math.round(Date.now() / 1000)\n      const signature = await getSignedHash(this.signer, '', nonce)\n\n      // Construct the URL with the query parameters\n      const url = `${this.baseURL}/getHistory?userAddress=${userAddress}&nonce=${nonce}&signature=${signature}&page=${page}&pageSize=${pageSize}&storage=${storageType}`\n\n      // Send a GET request\n      const response: AxiosResponse = await axios.get(url)\n\n      // Validate the response status code\n      if (response.status !== 200) {\n        throw new Error('Failed to retrieve history.')\n      }\n\n      return response.data\n    } catch (error) {\n      console.error('An error occurred while fetching history:', error)\n      throw error\n    }\n  }\n}\n"],"names":["minErc20Abi","getSignedHash","async","signer","quoteId","nonce","message","sha256","toUtf8Bytes","toString","signMessage","signature","Client","constructor","baseURL","address","dbsAddress","this","validateBaseURL","trim","Error","validator","isURL","require_tld","getFileSizes","files","map","file","length","fs","statSync","size","getStorageInfo","axios","get","data","getQuote","args","filePath","fileInfo","fileSizes","payload","type","duration","payment","userAddress","post","upload","tokenAddress","quoteFee","filePaths","Math","round","Date","now","token","Contract","approveAddress","approve","wait","formData","FormData","forEach","path","index","append","createReadStream","uploadUrl","console","log","headers","_extends","getHeaders","error","uploadBrowser","Array","from","name","getStatus","params","getLink","registerMicroservice","getHistory","page","pageSize","storageType","getAddress","url","response","status"],"mappings":"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"}