{"version":3,"file":"lib.umd.js","sources":["../src/utils/index.ts","../src/UploaderClient.ts"],"sourcesContent":["import { Signer, sha256, toUtf8Bytes } from 'ethers'\n\n/**\n * @param {string} quoteId - The quote ID.\n * @param {Signer} signer The signer object.\n * @param {number} nonce - A timestamp (must be higher than the previously stored nonce for the user).\n * @returns {Promise<string>} - A promise that resolves to the signed hash.\n */\nexport const getSignedHash = async (signer: Signer, quoteId: string, nonce: number) => {\n  // Concatenate the message\n  const message = sha256(toUtf8Bytes(quoteId + nonce.toString()))\n\n  // Sign the original message directly\n  const signature = await signer.signMessage(message)\n\n  return signature\n}\n","import { Signer, Contract } from 'ethers'\nimport axios, { AxiosResponse } from 'axios'\nimport {\n  StorageInfo,\n  GetQuoteArgs,\n  GetQuoteResult,\n  GetStatusResult,\n  GetLinkResult,\n  RegisterArgs,\n  UploaderGetQuoteArgs,\n  FileData\n} from './@types'\nimport { getSignedHash } from './utils'\nimport wMaticAbi from './utils/wMaticAbi.json'\nimport validator from 'validator'\nimport fs from 'fs'\nimport FormData from 'form-data'\n\n/**\n * Client is a TypeScript library for interacting with the Uploader API.\n */\nexport class UploaderClient {\n  private baseURL: string\n  private signer: Signer\n  private uploaderAddress: string\n\n  /**\n   * Creates an instance of the Client.\n   * @param {string} baseURL - The base URL of the Uploader API.\n   * @param {Signer} signer The signer object.\n   */\n  constructor(baseURL: string, address: string, signer?: Signer) {\n    this.validateBaseURL(baseURL)\n    this.baseURL = baseURL\n    this.signer = signer\n    this.uploaderAddress = address\n  }\n\n  private validateBaseURL(baseURL: string): void {\n    if (!baseURL || typeof baseURL !== 'string' || baseURL.trim() === '') {\n      throw new Error('Invalid baseURL provided. baseURL cannot be empty or undefined.')\n    }\n\n    // Using the validator library to check for a valid URL.\n    // Including { require_tld: false } to allow 'localhost' as a valid URL.\n    if (!validator.isURL(baseURL, { require_tld: false })) {\n      throw new Error('Invalid baseURL format provided.')\n    }\n  }\n\n  private getFileSizes(files: string[]): FileData[] {\n    return files.map((file) => {\n      const stats = fs.statSync(file)\n      return {\n        length: stats.size\n      }\n    })\n  }\n\n  /**\n   * Fetches information about supported storage types and payments.\n   *\n   * @returns {Promise<StorageInfo[]>} - A promise that resolves to an array of storage information.\n   */\n  async getStorageInfo(): Promise<StorageInfo[]> {\n    const response = await axios.get<StorageInfo[]>(`${this.baseURL}/`)\n    return response.data\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage.\n   *\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>} - A promise that resolves to the quote result.\n   */\n  async getQuote(args: GetQuoteArgs): Promise<GetQuoteResult> {\n    if (!args.filePath && !args.fileInfo) {\n      throw new Error('Either filePath or fileInfo must be provided.')\n    }\n    const fileSizes: FileData[] = args.fileInfo || this.getFileSizes(args.filePath)\n\n    const payload: UploaderGetQuoteArgs = {\n      type: args.type,\n      files: fileSizes,\n      duration: args.duration,\n      payment: args.payment,\n      userAddress: args.userAddress\n    }\n\n    const response = await axios.post<GetQuoteResult>(`${this.baseURL}/getQuote`, payload)\n\n    return response.data\n  }\n\n  /**\n   * Uploads files according to the quote request.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @param {Buffer[]} files - An array of files to upload.\n   * @returns {Promise<void>}\n   */\n  async upload(\n    quoteId: string,\n    tokenAddress: string,\n    quoteFee: string,\n    filePaths: string[],\n    type: string\n  ): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n\n      if (type !== 'ipfs') {\n        const token = new Contract(tokenAddress, wMaticAbi, this.signer)\n\n        // This needs to be updated to include other addresses once we have the deposit contract deployed on other networks\n        const approveAddress =\n          type === 'filecoin'\n            ? '0x0ff9092e55d9f6CCB0DD4C490754811bc0839866'\n            : this.uploaderAddress\n\n        await (await token.approve(approveAddress, quoteFee)).wait()\n      }\n\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n\n      const formData = new FormData()\n      // Add each file to the form data\n      filePaths.forEach((path, index) => {\n        formData.append(`file${index + 1}`, fs.createReadStream(path))\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n      console.log('uploadUrl', uploadUrl)\n\n      const response = await axios.post(uploadUrl, formData, {\n        headers: {\n          ...formData.getHeaders()\n        }\n      })\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  async uploadBrowser(\n    quoteId: string,\n    tokenAddress: string,\n    quoteFee: string,\n    files: FileList,\n    type: string\n  ): Promise<any> {\n    try {\n      const nonce = Math.round(Date.now() / 1000)\n      if (type !== 'ipfs') {\n        const token = new Contract(tokenAddress, wMaticAbi, this.signer)\n        console.log(`quote fee: ${quoteFee}`)\n\n        // This needs to be updated to include other addresses once we have the deposit contract deployed on other networks\n        const approveAddress =\n          type === 'filecoin'\n            ? '0x0ff9092e55d9f6CCB0DD4C490754811bc0839866'\n            : this.uploaderAddress\n\n        console.log(\n          `Calling approval with address: ${approveAddress} and amount: ${quoteFee}`\n        )\n        const tx = await token.approve(approveAddress, quoteFee)\n        const receipt = await tx.wait(1)\n        console.log('transaction receipt', receipt)\n\n        // check user has sufficient balance\n        const balance = await token.balanceOf(this.signer.getAddress())\n        console.log(`User balance of WMATIC: ${balance}`)\n\n        if (balance < quoteFee) {\n          console.log(\n            `User balance of ${balance} WMATIC is less than quote fee of ${quoteFee}`\n          )\n          throw new Error('Insufficient WMATIC balance')\n        }\n      }\n\n      const signature = await getSignedHash(this.signer, quoteId, nonce)\n\n      const formData = new FormData()\n      // Add each file to the form data\n      Array.from(files).forEach((file, index) => {\n        formData.append(`file${index + 1}`, file, file.name)\n      })\n\n      const uploadUrl = `${this.baseURL}/upload?quoteId=${quoteId}&nonce=${nonce}&signature=${signature}`\n\n      const response = await axios.post(uploadUrl, formData)\n\n      return response\n    } catch (error) {\n      console.error('Error:', error)\n      return error.data\n    }\n  }\n\n  /**\n   * Fetches a quote for storing files on a specific storage and uploads files according to the quote request.\n   * @param {GetQuoteArgs} args - The arguments needed for getting a quote.\n   * @returns {Promise<GetQuoteResult>}\n   */\n  // async getQuoteAndUpload(args: GetQuoteArgs): Promise<any> {\n  //   const quote = await this.getQuote(args)\n  //   const uploadResponse = await this.upload(quote.quoteId, args.files)\n  //   return uploadResponse\n  // }\n\n  /**\n   * Fetches the status of a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetStatusResult>} - A promise that resolves to the status result.\n   */\n  async getStatus(quoteId: string): Promise<GetStatusResult> {\n    const response = await axios.get<GetStatusResult>(`${this.baseURL}/getStatus`, {\n      params: {\n        quoteId\n      }\n    })\n    return response.data\n  }\n\n  /**\n   * Fetches the DDO files object for a job.\n   *\n   * @param {string} quoteId - The quote ID.\n   * @returns {Promise<GetLinkResult[]>} - A promise that resolves to an array of link results.\n   */\n\n  async getLink(quoteId: string): Promise<GetLinkResult[]> {\n    const nonce = Math.round(Date.now() / 1000)\n    const signature = await getSignedHash(this.signer, quoteId, nonce)\n    const response = await axios.get<GetLinkResult[]>(`${this.baseURL}/getLink`, {\n      params: { quoteId, nonce, signature }\n    })\n    return response.data\n  }\n\n  /**\n   * Registers a new microservice that handles a storage type.\n   *\n   * @param {RegisterArgs} args - The arguments needed for registering a microservice.\n   * @returns {Promise<void>}\n   */\n  async registerMicroservice(args: RegisterArgs): Promise<AxiosResponse> {\n    const response = await axios.post(`${this.baseURL}/register`, args)\n    return response\n  }\n\n  /**\n   * Retrieves the quote history for the given user address, nonce, and signature.\n   *\n   * @returns {Promise<any>} A promise that resolves to the quote history data.\n   */\n  async getHistory(\n    page: number = 1,\n    pageSize: number = 25,\n    storageType: string\n  ): Promise<any> {\n    try {\n      const userAddress = await this.signer.getAddress()\n      const nonce = Math.round(Date.now() / 1000)\n      const signature = await getSignedHash(this.signer, '', nonce)\n\n      // Construct the URL with the query parameters\n      const url = `${this.baseURL}/getHistory?userAddress=${userAddress}&nonce=${nonce}&signature=${signature}&page=${page}&pageSize=${pageSize}&storage=${storageType}`\n\n      // Send a GET request\n      const response: AxiosResponse = await axios.get(url)\n\n      // Validate the response status code\n      if (response.status !== 200) {\n        throw new Error('Failed to retrieve history.')\n      }\n\n      return response.data\n    } catch (error) {\n      console.error('An error occurred while fetching history:', error)\n      throw error\n    }\n  }\n}\n"],"names":["getSignedHash","signer","quoteId","nonce","message","sha256","toUtf8Bytes","toString","Promise","resolve","signMessage","e","reject","UploaderClient","baseURL","address","uploaderAddress","this","validateBaseURL","_proto","prototype","trim","Error","validator","isURL","require_tld","getFileSizes","files","map","file","length","fs","statSync","size","getStorageInfo","axios","get","then","response","data","getQuote","args","filePath","fileInfo","fileSizes","post","payload","type","duration","payment","userAddress","upload","tokenAddress","quoteFee","filePaths","_this3","_catch","_temp2","signature","formData","FormData","forEach","path","index","append","createReadStream","uploadUrl","console","log","headers","_extends","getHeaders","Math","round","Date","now","_temp","token","Contract","wMaticAbi","approve","_token$approve","wait","error","uploadBrowser","_exit","_this4","_temp4","_result","Array","from","name","_temp3","approveAddress","tx","receipt","balanceOf","getAddress","balance","getStatus","params","getLink","_this6","registerMicroservice","getHistory","page","pageSize","storageType","_this8","status"],"mappings":"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"}